=== Đóng góp cho một dự án

Bây giờ, bạn đã có tài khoản, nào cùng tìm hiểu cách Github giúp bạn đóng góp cho một dự án đã tồn tại.

==== Forking Projects

(((forking)))
Nếu bạn muốn đóng góp cho một dự án đã tồn tại, nhưng bạn không có quyền đẩy dữ liệu lên đó, bạn có thể ``fork'' dự án đó.
Khi bạn ``fork'' dự án, Github sẽ tạo một bản sao của dự án cho bạn; bây giờ dự án đã ở trên tài khoản của bạn và bạn có thể đẩy dữ liệu lên đó.

[NOTE]
====
Về mặt lịch sử, thuật ngữ ``fork'' có nghĩa khá tiêu cực, nó nghĩa rằng một ai đó đưa dự án mã nguồn mở theo một hướng khác, đôi khi là đối lập hoặc gây chia rẽ những người đang cống hiến cho dự án.
Trong Github, ``fork'' có nghĩa là một dự án giống hệt trong namespace của riêng bạn, nó cho phép bạn thực hiện những thay đổi tới dự án, đây là một cách để đóng góp cho dự án theo cách mở hơn.
====

Làm theo cách này, các dự án không phải lo lắng tới việc thêm user có quyền như là những người đóng góp, nghĩa là cấp cho user đó quyền đẩy dữ liệu lên dự án.
Mọi người có thể fork một dự án, đẩy công việc của mình tới nó, và đẩy những đóng góp của mình quay trở lại dự án gốc bằng Pull Request -- kiến thức này sẽ được trình bày ở phần tiếp theo.
Điều này mở ra một luồng thảo luận về code review, và owner và những người đóng góp có thể giao tiếp về những thay đổi cho tới khi owner hài lòng về nó, khi đó, owner có thể trộn nó vào dự án.

Để fork một dự án, tới trang của dự án và click vào nút ``Fork'' ở góc phải phía trên.

.Nút ``Fork''.
image::images/forkbutton.png[Nút ``Fork''.]

Sau vài giây, bạn sẽ có một dự án mới trên tài khoản github của mình, và ở đó bạn có quyền đẩy dữ liệu lên.

[[ch06-github_flow]]
==== The GitHub Flow

(((GitHub, Flow)))
Github hoạt động trên một quy trình hợp tác cụ thể, trung tâm của quy trình này là Pull Requests.
Quy trình này dành cho:

+ Khi bạn đang làm việc nhóm, và nhóm của bạn hợp tác thông qua một kho chứa duy nhất;

+ Hoặc, một công ty toàn cầu;

+ Hoặc, một mạng lưới kết nối những người lạ đang đóng góp cho một dự án nào đó thông qua hàng tá các fork.

It is centered on the <<ch03-git-branching#_topic_branch>> workflow được trình bày ở <<ch03-git-branching#ch03-git-branching>>.

Here's how it generally works:

1. Fork một dự án
2. Tạo một nhánh chủ đề từ nhánh `master`.
3. Đóng góp cho dự án bằng một vài commit.
4. Đẩy dữ liệu của nhánh này tới dự án trên Github của bạn.
5. Mở một `Pull Request` trên GitHub.
6. Thảo luận, Khi này bạn vẫn có thể tiếp tục thực hiện các commit nếu muốn.
7. Nếu đồng ý, Owner trộn công việc của bạn vào dự án gốc. Nếu không, họ đóng Pull Request của bạn.

Về mặt cơ bản thì đây là quy trình quản lí tích hợp được trình bày trong
 <<ch05-distributed-git#_integration_manager>>, nhưng thay vì sử dụng email để giao tiếp và review nhưng thay đổi, đội (team) sử dụng các công cụ của Github.

Cùng xem một ví dụ về đệ trình một thay đổi tới một dự án mã nguồn mở được hosted trên Github sử dụng Quy trình vừa nói ở trên.

===== Tạo một Pull Request

Tony đang tìm code để chạy trên vi điều khiển khả trình Arduino và anh ta tìm thấy một tệp chương trình tốt trên Github tại địa chỉ https://github.com/schacon/blink[].

.Dự án chúng ta muốn đóng góp.
image::images/blink-01-start.png[Dự án chúng ta muốn đóng góp.]

Vấn đề duy nhất là tốc độ nháy quá nhanh. Chúng ta nghĩ rằng sẽ tốt hơn nếu thời gian thay đổi trạng thái là 3 giây chứ không phải một giây.
Vậy cùng thay đổi chương trình và đệ trình nó quay trở lại như là một bản thay đổi dự kiến.

Đầu tiên, chúng ta click vào nút 'Fork' như đã nói ở phần trên để có được một bản sao dự án trên tài khoản Github của bạn.
Giả sử, username tải khoản Github của bạn là `tonychacon`, thì bản sao dự án bây giờ được lưu tại `https://github.com/tonychacon/blink` và đây là nơi chúng ta có thể sửa nó.
Chúng ta sẽ clone nó xuống máy tính, tạo một nhánh chủ đề, thay đổi code và cuối cùng đẩy công việc bạn đã làm quay trở lại Github.

[source,console]
----
$ git clone https://github.com/tonychacon/blink <1>
Cloning into 'blink'...

$ cd blink
$ git checkout -b slow-blink <2>
Switched to a new branch 'slow-blink'

$ sed -i '' 's/1000/3000/' blink.ino (macOS) <3>
# If you're on a Linux system, do this instead:
# $ sed -i 's/1000/3000/' blink.ino <3>

$ git diff --word-diff <4>
diff --git a/blink.ino b/blink.ino
index 15b9911..a6cc5a5 100644
--- a/blink.ino
+++ b/blink.ino
@@ -18,7 +18,7 @@ void setup() {
// the loop routine runs over and over again forever:
void loop() {
  digitalWrite(led, HIGH);   // turn the LED on (HIGH is the voltage level)
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
  digitalWrite(led, LOW);    // turn the LED off by making the voltage LOW
  [-delay(1000);-]{+delay(3000);+}               // wait for a second
}

$ git commit -a -m 'three seconds is better' <5>
[slow-blink 5ca509d] three seconds is better
 1 file changed, 2 insertions(+), 2 deletions(-)

$ git push origin slow-blink <6>
Username for 'https://github.com': tonychacon
Password for 'https://tonychacon@github.com':
Counting objects: 5, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 340 bytes | 0 bytes/s, done.
Total 3 (delta 1), reused 0 (delta 0)
To https://github.com/tonychacon/blink
 * [new branch]      slow-blink -> slow-blink
----

<1> Clone dự án mà bạn fork từ dự án gốc (gọi là `dự án fork`) xuống máy tính của bạn
<2> Tạo một nhánh chủ đề
<3> Thực hiện công việc (thay đổi code theo ý mình)
<4> Kiểm tra công việc của bạn kết quả đã tốt
<5> Commit công việc của bạn tới nhánh chủ đề
<6> Đẩy nhánh chủ đề lên dự án trên `dự án fork`

Bây giờ, nếu chúng ta quay trở lại `dự án fork` trên Github, chúng ta có thể nhìn thấy rằng chúng ta đã đẩy nhánh chủ đề lên và có một nút nhấn to màu xanh để cho ta checkout những thay đổi vừa đẩy lên và mở một Pull Request tới dự án gốc.

Ngoài ra, có cách khác để tìm thấy nhánh của bạn và mở một Pull Request là tới trang `Branches` tại địa chỉ `https://github.com/<user>/<project>/branches`

.Nút ấn Pull Request
image::images/blink-02-pr.png[Nút ấn Pull Request]

(((GitHub, pull requests)))
Nếu click vào nút màu xanh đó, chúng ta sẽ thấy một màn hình hỏi chúng ta về tên và mô tả ngắn về Pull Request.
Bước này xứng đáng để ta tiêu tốn thời gian vào nó, vì một mô tả tốt sẽ giúp owner dự án cũ xác định được công việc bạn đang làm, và những thay đổi bạn thực hiện là đúng hay không, và có chấp nhận những thay đổi đó sẽ tăng cường dự án gốc hay không.

Chúng ta cũng nhìn thấy một danh sách các commit trong nhánh chủ đề mà nhánh `master` chưa có và các unified diff của tất cả những thay đổi sẽ được thực hiện nếu owner của dự án tiến hành trộn nó.

.Trang tạo Pull Request
image::images/blink-03-pull-request-open.png[Trang tạo Pull Request]

Khi bạn ấn nút 'Create pull request' thì owner của dự án gốc sẽ được thông báo rằng có ai đó đang đề xuất một thay đổi và sẽ liên kết tới một trang có tất cả những thông tin này trên đó.

[NOTE]
====
Mặc dù Pull Request được sử dụng rất phổ biến với các dự án công khai như thế này khi người đóng góp có một thay đổi tốt sẵn sàng được chấp nhận, nó cũng thường được sử dụng với các dự án nội bộ _ở giai đoạn đầu_ của chu trình phát triển. Vì bạn có thể tiếp tục đẩy nhánh chủ đề thậm chí *sau khi* Pull Request được mở, nên nó thường được mở trước và được sử dụng như là một cách để lặp lại công việc, chứ không mở ở cuối của mỗi quá trình.
====

===== Lặp lại trên một Pull Request

Tại thời điểm này, owner dự án có thể nhìn những thay đổi bạn đề nghị và quyết định trộn nó, không chấp nhận hoặc bình luận về nó. Cho rằng, anh ta thích ý tưởng, nhưng lại thích thời gian đèn tắt lâu hơn thời gian đèn sáng.

Vì vậy, cuộc trao đổi bắt đầu qua email trong Quy trình làm việc đã trình bày tại <<ch05-distributed-git#ch05-distributed-git>>, trên Gitub điều này xảy ra trực tuyến (online). Owner dự án có thể xem lại unified diff và bình luận ở bất kì dòng code nào khi anh ta click vào nó.

.Bình luận ở một dòng code trong một Pull Request
image::images/blink-04-pr-comment.png[Bình luận ở một dòng code trong một Pull Request]

Khi Người quản lí dự án (maintainer) thực hiện một bình luận, người tạo Pull Request (và bất kì ai theo dõi kho chứa này) sẽ nhận được một thông báo. Chúng ta sẽ nói về tùy chỉnh về thông báo này sau, nhưng nếu anh ta bật chức năng thông báo qua email, Tony sẽ có một email như sau:

[[_email_notification]]
.Các bình luận được gửi vào hòm thư điện tử
image::images/blink-04-email.png[Các bình luận được gửi vào hòm thư điện tử]

Bất kì ai cũng có thể viết bình luận chung (general comment) trên Pull Request. Trong <<_pr_discussion>> chúng ta có thể thấy một ví dụ về owner dự án bình luận trên một dòng code và sau đó để lại bình luận chung trong phần thảo luận. Bạn có thể thấy rằng các bình luận về code cũng được đưa vào trong cuộc nói chuyện.

[[_pr_discussion]]
.Trang thảo luận Pull Request
image::images/blink-05-general-comment.png[Trang thảo luận Pull Request]

Bây giờ, người đóng góp có thể nhìn thấy cái họ cần làm để công việc của họ được chấp nhận.
May mắn là điều này rất dễ.
Nếu sử dụng email, bạn phải cuộn lại để tìm trong một chuỗi email và đệ trình lại nó tới mailing list, còn với Github bạn chỉ cần commit lại tới nhánh chủ đề và đẩy lên, nó sẽ tự động cập nhật Pull Request.
Trong <<_pr_final>> bạn cũng có thể xem những bình luận code cũ đã được thu lại trong những Pull Request đã được chấp nhận, vì nó được thực hiện trên một dòng since it was made on a line that has since been changed.

Thêm các commit tới một Pull Request đã tồn tại sẽ không kích hoạt một thông báo, vậy nên khi Tony đẩy chỉnh sửa của anh ta lên thì anh ta quyết định thêm một bình luận để nhắc nhở owner rằng anh ta đã thay đổi theo yêu cầu.

[[_pr_final]]
.Pull Request final
image::images/blink-06-final.png[PR final]

Một điều rất thú vị là nếu bạn click vào ``Files Changed'' tab trên Pull Request, bạn sẽ có được ``unified'' diff -- nghĩa là, toàn bộ những thay đổi sẽ được mang tới nhánh chính của bạn nếu nhánh chủ đề được trộn. Theo thuật ngữ `git diff`, nó tự động cho bạn thấy sản phẩm của lệnh `git diff master...<branch>` cho nhánh mà Pull Request này dựa vào. Xem phần <<ch05-distributed-git#_what_is_introduced>> để biết về các loại diff.

Thứ khác bạn cũng thấy là Github kiểm tra xem nếu Pull Request trộn rõ ràng và cung cấp cho bạn một nút nhấn để thực hiện trộn trên máy chủ. Nút nhấn này chỉ có khi bạn có quyền ghi vào kho chứa và một sự trộn thông thường là có thể. Nếu bạn click, Github sẽ thực hiện trộn kiểu ``non-fast-forward'', nghĩa là thậm chí nếu trộn *có thể* là fast-forward, nó vẫn sẽ tạo một commit trộn.

Nếu bạn thích, bạn có thể kéo nhánh xuống và trộn nó ở trên máy tính của mình. Nếu bạn trộn nhánh này vào trong nhánh `master` và đẩy nó lên Github, thì Pull Request sẽ tự động được đóng lại.

Đây là quy trình làm việc mà hầu hết các dự án trên Github sử dụng. Nhánh chủ đề được tạo, Pull Requests được mở cho chúng, bắt đầu thảo luận, có thể thêm công việc được thực hiện trên nhánh và cuối cùng là request bị đóng hoặc được trộn.

[NOTE]
.Không chỉ dùng cho Fork
====
Quan trọng để thấy rằng bạn cũng có thể mở một Pull Request giữa hai nhánh trong cùng một kho chứa. Nếu bạn đang làm việc về một đặc trưng với một người khác và cả hai có quyền ghi tới dự án, bạn có thể đẩy nhánh chủ đề tới dự án và mở một Pull Request cho nó tới nhánh `master` để khởi tạo chức năng review code và thảo luận. Không cần phải cứ phải là fork.
====

==== Pull Requests nâng cao

Bây giờ chúng ta hiểu những điều cơ bản khi đóng góp cho một dự án trên Github, phần này trình bày những mẹo về Pull Request giúp cho bạn sử dụng nó hiệu quả hơn.

===== Pull Requests as Patches

Quan trọng để hiểu rằng, nhiều dự án thực sự không nghĩ về Pull Request như là hàng đợi của các bản vá hoàn hảo, giống như hầu hết các dự án dùng mailing list.
It's important to understand that many projects don't really think of Pull Requests as queues of perfect patches that should apply cleanly in order, as most mailing list-based projects think of patch series contributions.
Hầu hết các dự án github nghĩ về Pull Request như là cuộc thảo luận quanh một thay đổi được đề nghị, kết quả là một unified diff được chấp nhận.

Đây là sự khác biệt quan trọng, bởi vì nhìn chung những thay đổi được đề xuất trước khi code được cho là hoàn hảo,
This is an important distinction, because generally the change is suggested before the code is thought to be perfect, which is far more rare with mailing list based patch series contributions. This enables an earlier conversation with the maintainers so that arriving at the proper solution is more of a community effort. When code is proposed with a Pull Request and the maintainers or community suggest a change, the patch series is generally not re-rolled, but instead the difference is pushed as a new commit to the branch, moving the conversation forward with the context of the previous work intact.

For instance, if you go back and look again at <<_pr_final>>, you'll notice that the contributor did not rebase his commit and send another Pull Request. Instead they added new commits and pushed them to the existing branch. This way if you go back and look at this Pull Request in the future, you can easily find all of the context of why decisions were made. Pushing the ``Merge'' button on the site purposefully creates a merge commit that references the Pull Request so that it's easy to go back and research the original conversation if necessary.

===== Keeping up with Upstream

Nếu Pull Request của bạn đã lỗi thời hoặc nó không được trộn sáng sủa, bạn sẽ muốn sửa nó để người duy trì có thể dễ dàng trộn nó. Github sẽ kiểm trả điều này cho bạn cho bạn biết ở cuối mỗi Pull Request rằng trộn là tầm thường hoặc không.

[[_pr_fail]]
.Pull Request does not merge cleanly
image::images/pr-01-fail.png[PR merge failure]

Nếu bạn thấy giống như <<_pr_fail>>, bạn sẽ cần sửa nhánh của bạn để nó chuyển sang màu xanh và người duy trì không phải làm thêm công việc gì.

Bạn có hai lựa chọn để làm điều này. Bạn có thể rebase nhánh của bạn ở đỉnh của nhánh đích (thông thường, nhánh `master` của kho chứa mà bạn fork từ nó), hoặc bạn có thể trộn nhánh đích vào trong nhánh của bạn.
You have two main options in order to do this. You can either rebase your branch on top of whatever the target branch is (normally the `master` branch of the repository you forked), or you can merge the target branch into your branch.

Hầu hết các nhà phát triển trên Github sẽ chọn cách thứ hai, lí do chúng ta vừa nói ở phần trên.
Most developers on GitHub will choose to do the latter, for the same reasons we just went over in the previous section. What matters is the history and the final merge, so rebasing isn't getting you much other than a slightly cleaner history and in return is *far* more difficult and error prone.

If you want to merge in the target branch to make your Pull Request mergeable, you would add the original repository as a new remote, fetch from it, merge the main branch of that repository into your topic branch, fix any issues and finally push it back up to the same branch you opened the Pull Request on.

For example, let's say that in the ``tonychacon'' example we were using before, the original author made a change that would create a conflict in the Pull Request. Let's go through those steps.

[source,console]
----
$ git remote add upstream https://github.com/schacon/blink <1>

$ git fetch upstream <2>
remote: Counting objects: 3, done.
remote: Compressing objects: 100% (3/3), done.
Unpacking objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0)
From https://github.com/schacon/blink
 * [new branch]      master     -> upstream/master

$ git merge upstream/master <3>
Auto-merging blink.ino
CONFLICT (content): Merge conflict in blink.ino
Automatic merge failed; fix conflicts and then commit the result.

$ vim blink.ino <4>
$ git add blink.ino
$ git commit
[slow-blink 3c8d735] Merge remote-tracking branch 'upstream/master' \
    into slower-blink

$ git push origin slow-blink <5>
Counting objects: 6, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 682 bytes | 0 bytes/s, done.
Total 6 (delta 2), reused 0 (delta 0)
To https://github.com/tonychacon/blink
   ef4725c..3c8d735  slower-blink -> slow-blink
----

<1> Add the original repository as a remote named ``upstream''
<2> Fetch the newest work from that remote
<3> Merge the main branch of that repository into your topic branch
<4> Fix the conflict that occurred
<5> Push back up to the same topic branch

Once you do that, the Pull Request will be automatically updated and re-checked to see if it merges cleanly.

[[_pr_merge_fix]]
.Pull Request now merges cleanly
image::images/pr-02-merge-fix.png[PR fixed]

One of the great things about Git is that you can do that continuously. If you have a very long-running project, you can easily merge from the target branch over and over again and only have to deal with conflicts that have arisen since the last time that you merged, making the process very manageable.

If you absolutely wish to rebase the branch to clean it up, you can certainly do so, but it is highly encouraged to not force push over the branch that the Pull Request is already opened on. If other people have pulled it down and done more work on it, you run into all of the issues outlined in <<ch03-git-branching#_rebase_peril>>. Instead, push the rebased branch to a new branch on GitHub and open a brand new Pull Request referencing the old one, then close the original.

===== References

Câu hỏi tiếp theo là ``Làm thế nào để tham chiếu tới Pull Request cũ?''.
Your next question may be ``How do I reference the old Pull Request?''. It turns out there are many, many ways to reference other things almost anywhere you can write in GitHub.

Let's start with how to cross-reference another Pull Request or an Issue. All Pull Requests and Issues are assigned numbers and they are unique within the project. For example, you can't have Pull Request #3 _and_ Issue #3. If you want to reference any Pull Request or Issue from any other one, you can simply put `#<num>` in any comment or description. You can also be more specific if the Issue or Pull request lives somewhere else; write `username#<num>` if you're referring to an Issue or Pull Request in a fork of the repository you're in, or `username/repo#<num>` to reference something in another repository.

Let's look at an example. Say we rebased the branch in the previous example, created a new pull request for it, and now we want to reference the old pull request from the new one. We also want to reference an issue in the fork of the repository and an issue in a completely different project. We can fill out the description just like <<_pr_references>>.

[[_pr_references]]
.Cross references in a Pull Request.
image::images/mentions-01-syntax.png[PR references]

When we submit this pull request, we'll see all of that rendered like <<_pr_references_render>>.

[[_pr_references_render]]
.Cross references rendered in a Pull Request.
image::images/mentions-02-render.png[PR references rendered]

Notice that the full GitHub URL we put in there was shortened to just the information needed.

Now if Tony goes back and closes out the original Pull Request, we can see that by mentioning it in the new one, GitHub has automatically created a trackback event in the Pull Request timeline. This means that anyone who visits this Pull Request and sees that it is closed can easily link back to the one that superseded it. The link will look something like <<_pr_closed>>.

[[_pr_closed]]
.Link back to the new Pull Request in the closed Pull Request timeline.
image::images/mentions-03-closed.png[PR closed]

In addition to issue numbers, you can also reference a specific commit by SHA-1. You have to specify a full 40 character SHA-1, but if GitHub sees that in a comment, it will link directly to the commit. Again, you can reference commits in forks or other repositories in the same way you did with issues.

==== GitHub Flavored Markdown

Linking to other Issues is just the beginning of interesting things you can do with almost any text box on GitHub. In  Issue and Pull Request descriptions, comments, code comments and more, you can use what is called ``GitHub Flavored Markdown''. Markdown is like writing in plain text but which is rendered richly.

See <<_example_markdown>> for an example of how comments or text can be written and then rendered using Markdown.

[[_example_markdown]]
.An example of GitHub Flavored Markdown as written and as rendered.
image::images/markdown-01-example.png[Example Markdown]

The GitHub flavor of Markdown adds more things you can do beyond the basic Markdown syntax. These can all be really useful when creating useful Pull Request or Issue comments or descriptions.

===== Task Lists

The first really useful GitHub specific Markdown feature, especially for use in Pull Requests, is the Task List. A task list is a list of checkboxes of things you want to get done. Putting them into an Issue or Pull Request normally indicates things that you want to get done before you consider the item complete.

You can create a task list like this:

[source,text]
----
- [X] Write the code
- [ ] Write all the tests
- [ ] Document the code
----

If we include this in the description of our Pull Request or Issue, we'll see it rendered like <<_eg_task_lists>>

[[_eg_task_lists]]
.Task lists rendered in a Markdown comment.
image::images/markdown-02-tasks.png[Example Task List]

This is often used in Pull Requests to indicate what all you would like to get done on the branch before the Pull Request will be ready to merge. The really cool part is that you can simply click the checkboxes to update the comment -- you don't have to edit the Markdown directly to check tasks off.

What's more, GitHub will look for task lists in your Issues and Pull Requests and show them as metadata on the pages that list them out. For example, if you have a Pull Request with tasks and you look at the overview page of all Pull Requests, you can see how far done it is. This helps people break down Pull Requests into subtasks and helps other people track the progress of the branch. You can see an example of this in <<_task_list_progress>>.

[[_task_list_progress]]
.Task list summary in the Pull Request list.
image::images/markdown-03-task-summary.png[Example Task List]

These are incredibly useful when you open a Pull Request early and use it to track your progress through the implementation of the feature.

===== Code Snippets

You can also add code snippets to comments. This is especially useful if you want to present something that you _could_ try to do before actually implementing it as a commit on your branch. This is also often used to add example code of what is not working or what this Pull Request could implement.

To add a snippet of code you have to ``fence'' it in backticks.

[source,text]
----
```java
for(int i=0 ; i < 5 ; i++)
{
   System.out.println("i is : " + i);
}
```
----

If you add a language name like we did there with 'java', GitHub will also try to syntax highlight the snippet. In the case of the above example, it would end up rendering like <<_md_code>>.

[[_md_code]]
.Rendered fenced code example.
image::images/markdown-04-fenced-code.png[Rendered fenced code]

===== Quoting

If you're responding to a small part of a long comment, you can selectively quote out of the other comment by preceding the lines with the `>` character. In fact, this is so common and so useful that there is a keyboard shortcut for it. If you highlight text in a comment that you want to directly reply to and hit the `r` key, it will quote that text in the comment box for you.

The quotes look something like this:

[source,text]
----
> Whether 'tis Nobler in the mind to suffer
> The Slings and Arrows of outrageous Fortune,

How big are these slings and in particular, these arrows?
----

Once rendered, the comment will look like <<_md_quote>>.

[[_md_quote]]
.Rendered quoting example.
image::images/markdown-05-quote.png[Rendered quoting]

===== Emoji

Finally, you can also use emoji in your comments. This is actually used quite extensively in comments you see on many GitHub Issues and Pull Requests. There is even an emoji helper in GitHub. If you are typing a comment and you start with a `:` character, an autocompleter will help you find what you're looking for.

[[_md_emoji_auto]]
.Emoji autocompleter in action.
image::images/markdown-06-emoji-complete.png[Emoji autocompleter]

Emojis take the form of `:<name>:` anywhere in the comment. For instance, you could write something like this:

[source,text]
----
I :eyes: that :bug: and I :cold_sweat:.

:trophy: for :microscope: it.

:+1: and :sparkles: on this :ship:, it's :fire::poop:!

:clap::tada::panda_face:
----

When rendered, it would look something like <<_md_emoji>>.

[[_md_emoji]]
.Heavy emoji commenting.
image::images/markdown-07-emoji.png[Emoji]

Not that this is incredibly useful, but it does add an element of fun and emotion to a medium that is otherwise hard to convey emotion in.


[NOTE]
====
There are actually quite a number of web services that make use of emoji characters these days. A great cheat sheet to reference to find emoji that expresses what you want to say can be found at:

http://www.emoji-cheat-sheet.com
====

===== Images

This isn't technically GitHub Flavored Markdown, but it is incredibly useful. In addition to adding Markdown image links to comments, which can be difficult to find and embed URLs for, GitHub allows you to drag and drop images into text areas to embed them.

[[_md_drag]]
.Drag and drop images to upload them and auto-embed them.
image::images/markdown-08-drag-drop.png[Drag and drop images]

If you look at <<_md_drag>>, you can see a small ``Parsed as Markdown'' hint above the text area. Clicking on that will give you a full cheat sheet of everything you can do with Markdown on GitHub.
