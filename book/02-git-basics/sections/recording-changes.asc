=== Ghi những thay đổi tới Repository

Bây giờ, bạn có một Git repository trên máy tính của mình và một bản checkout hoặc _working copy_ phiên bản mới nhất của project.
Nhu cầu của bạn bây giờ là thay đổi các file và commit những thay đổi đó vào repository mỗi khi bạn nghĩ rằng cần lưu lại trạng thái ở thời điểm đó.

Nhớ rằng, mỗi file trong working directory của bạn có thể ở một trong hai trạng thái _tracked_ hoặc _untracked_.
Các tracked file là các file mà ở trong snapshot cuối cùng và chúng có thể đang unmodified, modified hoặc staged.
Tóm lại, tracked file là các file mà Git biết về nó.

Untracked file là những thứ ngược lại -- bất kì file trong working directory không ở trong snapshot cuối cùng và không ở trong trạng thái stage.
Khi bạn thực hiện clone một repository, tất cả các file trong working directory của bạn bây giờ sẽ ở trạng thái tracked và unmodified bởi vì Git vừa mới checkout chúng và bạn vẫn chưa thay đổi gì cả.

Khi bạn sửa file, chúng sẽ ở trạng thái modified. Bây giờ, bạn có thể stage chúng và sau đó commit tất cả những thay đổi đã được stage, chu trình cứ lặp lại như vậy.

.Chu trình trạng thái file trong Git.
image::images/lifecycle.png[The lifecycle of the status of your files.]

[[_checking_status]]
==== Kiểm tra trạng thái các file của bạn

Công cụ để bạn xác định file nào đang ở trong trạng thái nào là lệnh `git status`.(((git commands, status)))
Nếu bạn chạy lệnh này ngay sau khi clone, bạn sẽ thấy như sau:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
----

Điều này nghĩa là bạn có một working directory trong sạch -- hay nói cách khác là không có tracked file nào đã được thay đổi nội dung.
Git cũng không thấy bất kì untracked file nào ở đây.
Cuối cùng, lệnh nào nói cho bạn biết bạn đang làm việc ở branch nào và nhắc cho bạn biết rằng branch nó tương ứng với branch nào trên server.
Branch mặc định luôn là ``master'', bây giờ bạn chưa cần tìm hiểu sâu về vấn đề này ở đây.
Trong <<ch03-git-branching#ch03-git-branching>> trình bày về branching bạn sẽ hiểu rõ vấn đề này hơn.
Ví dụ, thêm một file mới tên là `README` tới project của bạn.
Nếu file không có từ trước, và bạn chạy lệnh `git status`, bạn sẽ thấy nó ở trong phần untracked file như sau:

[source,console]
----
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
----

Bạn thấy rằng `README` file vừa mới tạo ở trạng thái untracked, bởi vì nó trong phần có tiêu đề là ``Untracked files''.
Untracked có nghĩa là Git thấy nó trong thư mục nhưng chưa có bất kì một snapshot (commit) nào của nó trong cơ sở dữ liệu; Git sẽ không chứa nó trong commit tiếp theo trừ khi bạn tracked nó bằng lệnh `git add`.
Điều này rất có ý nghĩa trong trường hợp bạn không muốn chứa các binary file hoặc các file mà không muốn chứa trong snapshot.
Nếu bạn muốn bắt đầu track nó, cùng tìm hiểu phần tiếp theo.

[[_tracking_files]]
==== Tracking New Files

Để bắt đầu track một file mới, sử dụng lệnh `git add`.(((git commands, add)))
Ví dụ, để track `README` file, chạy lệnh sau:

[source,console]
----
$ git add README
----

Bây giờ, nếu bạn chạy lại lệnh `git status`, bạn sẽ thấy rằng nó đã được tracked và staged, sẵn sàng cho commit:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

----

Có thể nói rằng nó đã ở trạng thái staged bởi vì nó ở dưới mục có tiêu đề là ``Changes to be committed''.
Nếu bây giờ bạn commit thì nội dung của file tại thời điểm chạy `git add` sẽ ở trong snapshot.
Lệnh `git add` sử dụng pathname của file hoặc thư mục; nếu nó là một thư muc, lệnh sẽ add toàn bộ các file trong thư mục đó.

==== Staging Modified Files

Bây giờ thay đổi một file đã được track (tracked file).
Nếu bạn thay đổi một tracked file tên là `CONTRIBUTING.md` và sau đó chạy lệnh `git status`, bạn sẽ thấy kết quả như sau:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

`CONTRIBUTING.md` xuất hiện trong phần có tên là ``Changes not staged for commit'' -- nó có nghĩa rằng một file đã được track và nội dung của nó đã thay đổi so với snapshot mới nhất, nhưng nó vẫn chưa được stage.
Để stage nó, chạy lệnh `git add`.
`git add` là lệnh có nhiều mục đích -- nó có thể sử dụng để bắt đầu track một file mới, để stage file, và làm những việc khác như đánh dấu các merge-conflicted file ở trạng thái resolved.
Sau khi đã stage nó, chạy lại lệnh `git status`, ta được như sau:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

Cả hai file bây giờ đã được stage và sẵn sàng cho commit.
Ở thời điểm bây giờ, giả sử bạn nhớ rằng bạn muốn sửa nội dung của `CONTRIBUTING.md` trước khi bạn commit nó.
Bạn mở nó lại và sửa nó như ý muốn, và sửa xong giờ bạn đã sẵn sàng để commit nó.
Bây giờ, ta chạy lại lệnh `git status` sẽ thấy như sau:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Chuyện gì xảy ra vậy?
`CONTRIBUTING.md` có cả ở cả 2 trạng thái là unstaged và staged.
Nếu bây giờ bạn commit thì nội dung file tại thời điểm chạy lệnh `git add` sẽ ở trong snapshot chứ không phải phiên bản bạn sửa cuối cùng.
Nếu bạn sửa một file sau khi bạn chạy lệnh `git add` thì bạn phải chạy lại lệnh `git add` để stage phiên bản cuối cùng của file.

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
----

==== Short Status

Kết quả của chạy lệnh `git status` chi tiết, nhưng nó cũng quá dài dòng.
Git cho phép hiển thị status ngắn gọn hơn bằng lệnh `git status -s` hoặc `git status --short` như sau:

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

Các file không được track có dấu `??` ở trước, các file mới mà đã được stage thì phía trước có dấu `A`, các file đã sửa có dấu `M` và vân vân.
Có hai cột được sử dụng: cột bên trái cùng là trạng thái của vùng staging và cột bên phải là trạng thái của working directory.
Ví dụ, trong short status ở trên, `README` được sửa trong working directory nhưng vẫn chưa được stage, trong khi `lib/simplegit.rb` đã được sửa và được stage. `Rakefile` đã được sửa, được stage và sửa lại.

[[_ignoring]]
==== Ignoring Files

Thông thường, bạn sẽ có một lớp các file bạn không muốn git tự động add hoặc thậm chí là hiển thị trạng thái untracked.
Thường thì đây là các file tự động được tạo ra như log gile hoặc các file được tạo ra trong quá trình build.
Trong các trường hợp như thế, bạn có thể tạo một file chứa pattern có tên là `.gitignore`.(((ignoring files)))
Đây là một ví dụ về `.gitignore`:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

Dòng đầu tiên nói với Git bỏ qua bất kì file nào kết thúc với ``.o'' hoặc ``.a'' -- đây là các object file và archive file được tạo ra trong quá trình build.
Dòng thứ hai nói với git bỏ qua tất cả các file mà tên của nó kết thúc với dấu `~`, đây là kí tự được sử dụng bởi nhừ text editor như Emacs để chỉ thị đó là tệp tạm thời.
Việc sử dụng `.gitignore` cho repository mới trước khi bạn bắt đầu làm việc là một ý tưởng hay để bạn không commit những file bạn không muốn nó có trong Git repository.

Luật cho pattern của `.gitignore` như sau:

*  Các dòng trống hoặc các dòng bắt đầu bằng kí tự `#` sẽ bị bỏ qua.
*  Các pattern theo chuẩn glob được sử dụng
*  Có thể bắt đầu pattern với một kí tự `/` có nghĩa là chỉ tác dụng với thư mục hiện tại chứ không tác dụng với thư mục con.
*  Có thể đặt dấu forward slash (`/`) ở cuối của pattern để chỉ rõ đó là một thư mục.
*  Bắt đầu pattern bằng dấu chấm than (`!`) có ý nghĩa ngược lại với pattern gốc.

Glob pattern giống với regular expression của shell.
Một kí tự sao `*` có nghĩa là không hoặc có bất kì kí tự nào; `[abc]' có nghĩa là bất kì kí tự nào bên trong ngặc vuông (trong trường hợp này là a,b, hoặc c); một dấu hỏi `?` có nghĩa là một kí tự bất kì nào đó; và dấu ngoặc vuông mà nội dung bên trong nó cách nhau bởi dấu gạch giữa thì có nghĩa là bất kì kí tự nào giữa chúng, ví dụ `[0-9]` có nghĩa là bất kì kí tự nào từ 0 tới 9.
Bạn cũng có thể sử dụng hai dấu sao để chỉ thư muc lồng nhau, ví dụ `a/**/z` có thể là `a/z`, `a/b/z`, `a/b/c/z`, và vân vân.

Đây là một ví dụ khác về `.gitignore`:

[source]
----
# bỏ qua tất cả các file kết thúc với .a
*.a

# track lib.a kể cả khi đã bỏ qua tất cả các file kết thúc là .a ở trên
!lib.a

# bỏ qua TODO file trong thư mục hiện tại, các TODO file trong thư mục con vẫn track bình thường
/TODO

# bỏ qua tất cả các file trong thư mục có tên là build
build/

# bỏ qua doc/notes.txt, những track doc/server/arch.txt
doc/*.txt

# bỏ qua tất cả các file .pdf trong thư mục doc/ và trong các thư mục con của nó
doc/**/*.pdf
----

[TIP]
====
Github có rất nhiều các file `.gitignore` cho nhiều loại project và ngôn ngữ tại https://github.com/github/gitignore[] , có thể dùng tham khảo cho project của bạn.
====

[NOTE]
====
Trong trường hợp đơn giản, một repository có thể chỉ có một file `.gitignore` trong thư mục chính, file này sẽ được áp dụng tới toàn bộ repository. Mặc dù vậy, cũng có thể có các file `.gitignore` ở trong các thư mục con.
Các file `.gitignore` này chỉ được áp dụng với các file trong thư mục nó được đặt.
(source code của Linux kernel có tới 206 file `.gitignore`)

Phạm vi cuốn sách này không đi chi tiết về sử dụng nhiều file `.gitignore`; để tìm hiểu chi tiết hơn sử dụng lệnh `man gitignore`.
====

[[_git_diff_staged]]
==== Viewing Your Staged and Unstaged Changes

Nếu lệnh `git status` cung cấp thông tin quá mơ hồ cho bạn -- bạn muốn biết chính xác bạn đã thay đổi cái gì chứ không phải chỉ là file đã thay đổi nội dụng -- để làm điều này sử dụng lệnh `git diff`. (((git commands, diff)))
Chúng tôi sẽ trình bày chi tiết về lệnh `git diff` sau, nhưng bạn sẽ sử dụng nó thường xuyên để trả lời hai câu hỏi: một là, cái bạn đã thay đổi nhưng chưa stage là gì? hai là, cái bạn đã stage nhưng chưa commit?
Lệnh `git status` đã trả lời câu hỏi này nhưng chỉ chung chung bằng cách nêu tên file, nhưng lệnh `git diff` sẽ cho bạn biết chính xác dòng nào được thêm và dòng nào đã bị xóa.

Tiếp tục sử dụng `README` file và `CONTRIBUTING.md` làm ví dụ. Sửa và stage `README` và sau đó sửa `CONTRIBUTING.md` mà không stage.
Nếu bạn chạy lệnh `git status`, bạn sẽ có kết quả như sau:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Để xem cái gì bạn đã thay đổi mà chưa stage, chạy lệnh `git diff` với không argument như sau:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

Lệnh này so sánh nội dung ở trong working directory với nội dung trong vùng staging area.
Kết quả cho bạn biết rằng những thay đổi bạn thực hiện vẫn chưa được stage.

Nếu bạn muốn xem cái bạn đã stage nhưng chưa commit, bạn sử dụng lệnh `git diff --staged`.
Lệnh này sẽ so sánh nội dung trong vùng stagging với commit mới nhất:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

Ta thấy rằng, lệnh `git diff` tự nó không hiện ra toàn bộ những thay đổi được thực hiện kể từ lần commit cuối cùng -- chỉ có những thay đổi vẫn chưa được stage. Nếu bạn đã stage tất cả những thay đổi, thì lệnh `git diff` sẽ không hiện ra nội dung gì.

Ví dụ khác, nếu bạn stage file `CONTRIBUTING.md` và sau đó sửa nó, bạn có thể sử dụng lệnh `git diff` để xem những thay đổi mà đã được stage và cả những thay đổi chưa được stage.
Ví dụ, bây giờ working directory của bạn như sau:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Bây giờ bạn có thể sử dụng lệnh `git diff` để xem cái gì vẫn chưa được stage.

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

và lệnh `git dif --cached` để xem cái bạn đã stage (hai option `--staged` và `--cached` giống nhau)

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
.Git Diff trong các công cụ ngoài
====
Chúng ta sẽ tiếp tục sử dụng lệnh `git diff` theo các cách khác nhau trong phần còn lại của cuốn sách này.
Có thể xem những thay đổi bằng các công cụ đồ họa hoặc các phần mềm khác.
Thay cho việc chạy lệnh `git diff` bạn chạy lệnh `git difftool`, thì những thay đổi khi này có thể đọc bằng các phần mềm khác như emerge, vimdiff,...(kể cả các phần mềm thương mại).
Chạy lệnh `git difftool --tool-help` để xem thêm cách sử dụng.
====

[[_committing_changes]]
==== Committing Your Changes

Bây giờ, vùng staging đã như bạn mong muốn, bạn có thể commit.
Nhớ rằng bất kì cái gì vẫn chưa được stage (tức là chưa ở trong vùng staging) -- bất kì file bạn tạo hoặc sửa mà chưa chạy lệnh `git add` thì sẽ không được commit.
Chúng sẽ vẫn chỉ ở trạng thái modified trên ổ đĩa của bạn mà thôi.
Trong trường hợp này, trước khi commit, bạn nên chạy lại lệnh `git status` để xem lại để sẵn sàng cho commit.(((git commands, status)))
Cách đơn giản nhất để commit là dùng lệnh `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Lệnh này sẽ khởi động text editor mặc định trên máy tính của bạn
(Text editor mặc định được thiết lập bằng biến `EDITOR` -- thường là vim hoặc emacs, bạn có thể cấu hình bất kì editor nào mà mình muốn sử dụng lệnh `git config --global core.editor` giống như trong <<ch01-getting-started#ch01-getting-started>>).(((editor, changing default)))(((git commands, config)))

Trong editor sẽ hiển thị đoạn nội dung như sau (ví dụ này là Vim screen):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

Bạn có thể thấy rằng nội dung message mặc định chứa output của lệnh `git status` đã bị comment và trên cùng có một dòng trống.
Bạn có thể xóa các comment có sẵn này và nhập message của mình, hoặc bạn có thể cứ để đó để sau này giúp bạn nhớ cái mà bạn đang commit.
(Nếu bạn muốn thay phần nội dụng là đầu ra của lẹnh `git status` bằng đầu ra của lệnh `git diff` thì sử dụng option `-v` như sau `git commit -v`.

Bạn cũng có thể nhập luôn message mà không cần nhập qua editor như trên bằng sử dụng cờ `-m`, như sau:

[source,console]
----
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Bây giờ bạn đã tạo commit đầu tiên!
Bạn có thể thấy rằng kết quả của lệnh commit sẽ cho bạn biết các thông tin: branch nào bạn lưu commit (`master`), commit có SHA-1 checksum là gì (`463dc4f`), bao nhiêu file đã thay đổi, và thống kê số dòng được thêm và bị xóa.

Nhớ rằng, commit chỉ sử dụng những nội dung trong vùng staging (tức là đã được staged).
Bất kì cái gì mà chưa được stage thì vẫn ở trong trạng thái modified.
Mỗi một lần commit tức là bạn đã lưu trạng thái của project ở thời điểm đó, bất kì thời điểm sau này bạn có thể khôi phục lại trạng thái commit đó hoặc dùng nó để so sánh với các commit khác.

==== Skipping the Staging Area

(((staging area, skipping)))
Mặc dù, dữ liệu bạn muốn commit phải chuyển sang vùng staging, nhưng đôi khi điều đó gây phiền phức.
Nếu bạn muốn bỏ qua việc phải đưa dữ liệu vào vùng staging, mà commit luôn những thay đổi, git cung cấp cách làm việc đó bằng sử dụng `-a` option trong lệnh `git commit` như sau:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Ta thấy răng không cần phải chạy lệnh `git add` trước khi commit.
Bởi vì cờ `-a` có nghĩa là chứa toàn bộ các file thay đổi. Chức năng này thuận tiện, nhưng cần thận vì đôi khi nó làm cho chứa những thay đổi không mong muốn mà lại có trong commit.

[[_removing_files]]
==== Removing Files

(((files, removing)))
Để xóa một file từ git, bạn phải xóa nó khỏi tracked files (nói chính xác hơn là xóa nó khỏi vùng staging) và sau đó commit.
lệnh `git rm` thực hiện công việc đó, và lệnh này cũng xóa file khỏi working directory, bởi vậy bạn sẽ không nhìn thấy nó trong mục untracked file nữa.

Nếu bạn chỉ xóa file khởi working directory như với file thông thường, khi chạy lệnh `git status` nó sẽ hiển thị trong mục ``Changes not staged for commit'':

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Sau đó, nếu bạn chạy lệnh `git rm` thì file đã xóa sẽ được cập nhật vào trong vùng staging.

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

Trường hợp bạn sửa file và đã chuyển nó vào vùng staging, thì bạn phải xóa nó bằng cờ `-f`.
Đây là cách an toàn của Git để ngăn chặn xóa nhầm dữ liệu vẫn chưa được commit, bởi vì xóa dữ liệu chưa commit thì không thể khôi phục được.

Trường hợp nữa là, bạn muốn giữ file trong working tree nhưng xóa nó khỏi staging. Hay nói cách khác, bạn muốn file đang track trở thành untrack.
Chức năng này hữu ích trong trường hợp bạn không muốn track một file nào đó nhưng lại quên thêm nó vào `.gitignore`. Để thực hiện chức năng này thêm `--cached` vào lệnh `git rm` như ví dụ sau:

[source,console]
----
$ git rm --cached README
----

Bạn có thể dùng tên file, tên thư mục và glob pattern đối với lệnh `git rm`.
Giống như ví dụ sau:

[source,console]
----
$ git rm log/\*.log
----

Note the backslash (`\`) in front of the `*`.
This is necessary because Git does its own filename expansion in addition to your shell's filename expansion.
This command removes all files that have the `.log` extension in the `log/` directory.
Or, you can do something like this:

[source,console]
----
$ git rm \*~
----

Lệnh này xóa bỏ toàn bộ các file mà tên của nó kết thúc với kí tự `~`.

[[_git_mv]]
==== Moving Files

(((files, moving)))
Không giống như các VCS khác, Git không track sự di chuyển của file.
Nếu bạn đổi tên một file trong Git, sẽ không có metadata nào được lưu trong Git nói rằng bạn đã đổi tên file.
Mặc dù vậy, Git khá thông minh trong việc nhận ra điều đó.

Nếu bạn muốn đổi tên một file trong Git, bạn có thể làm như sau:

[source,console]
----
$ git mv file_from file_to
----

Với lệnh trên thì Git coi nó như là đổi tên file:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

Lệnh trên tương đương với:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git ngấm ngầm hiểu rằng đây chính là đổi tên file, vậy không quan trọng là bạn đổi tên file theo cách nào.
Chỉ có sự khác biệt là thay vì một lệnh phải chạy tới 3 lệnh để thực hiện --- đây là chức năng thuận tiện.
