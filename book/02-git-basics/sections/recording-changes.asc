=== Ghi những thay đổi tới Repository

Bây giờ, bạn có một Git repository trên máy tính của mình và một bản checkout hoặc _working copy_ phiên bản mới nhất của project.
Nhu cầu của bạn bây giờ là thay đổi các file và commit những thay đổi đó vào repository mỗi khi bạn nghĩ rằng cần lưu lại trạng thái ở thời điểm đó.

Nhớ rằng, mỗi file trong working directory của bạn có thể ở một trong hai trạng thái _tracked_ hoặc _untracked_.
Các tracked file là các file mà ở trong snapshot cuối cùng và chúng có thể đang unmodified, modified hoặc staged.
Tóm lại, tracked file là các file mà Git biết về nó.

Untracked file là những thứ ngược lại -- bất kì file trong working directory không ở trong snapshot cuối cùng và không ở trong trạng thái stage.
Khi bạn thực hiện clone một repository, tất cả các file trong working directory của bạn bây giờ sẽ ở trạng thái tracked và unmodified bởi vì Git vừa mới checkout chúng và bạn vẫn chưa thay đổi gì cả.

Khi bạn sửa file, chúng sẽ ở trạng thái modified. Bây giờ, bạn có thể stage chúng và sau đó commit tất cả những thay đổi đã được stage, chu trình cứ lặp lại như vậy.

.Chu trình trạng thái file trong Git.
image::images/lifecycle.png[The lifecycle of the status of your files.]

[[_checking_status]]
==== Kiểm tra trạng thái các file của bạn

Công cụ để bạn xác định file nào đang ở trong trạng thái nào là lệnh `git status`.(((git commands, status)))
Nếu bạn chạy lệnh này ngay sau khi clone, bạn sẽ thấy như sau:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
----

Điều này nghĩa là bạn có một working directory trong sạch -- hay nói cách khác là không có tracked file nào đã được thay đổi nội dung.
Git cũng không thấy bất kì untracked file nào ở đây.
Cuối cùng, lệnh nào nói cho bạn biết bạn đang làm việc ở branch nào và nhắc cho bạn biết rằng branch nó tương ứng với branch nào trên server.
Branch mặc định luôn là ``master'', bây giờ bạn chưa cần tìm hiểu sâu về vấn đề này ở đây.
Trong <<ch03-git-branching#ch03-git-branching>> trình bày về branching bạn sẽ hiểu rõ vấn đề này hơn.
Ví dụ, thêm một file mới tên là `README` tới project của bạn.
Nếu file không có từ trước, và bạn chạy lệnh `git status`, bạn sẽ thấy nó ở trong phần untracked file như sau:

[source,console]
----
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
----

Bạn thấy rằng `README` file vừa mới tạo ở trạng thái untracked, bởi vì nó trong phần có tiêu đề là ``Untracked files''.
Untracked có nghĩa là Git thấy nó trong thư mục nhưng chưa có bất kì một snapshot (commit) nào của nó trong cơ sở dữ liệu; Git sẽ không chứa nó trong commit tiếp theo trừ khi bạn tracked nó bằng lệnh `git add`.
Điều này rất có ý nghĩa trong trường hợp bạn không muốn chứa các binary file hoặc các file mà không muốn chứa trong snapshot.
Nếu bạn muốn bắt đầu track nó, cùng tìm hiểu phần tiếp theo.

[[_tracking_files]]
==== Tracking New Files

Để bắt đầu track một file mới, sử dụng lệnh `git add`.(((git commands, add)))
Ví dụ, để track `README` file, chạy lệnh sau:

[source,console]
----
$ git add README
----

Bây giờ, nếu bạn chạy lại lệnh `git status`, bạn sẽ thấy rằng nó đã được tracked và staged, sẵn sàng cho commit:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

----

Có thể nói rằng nó đã ở trạng thái staged bởi vì nó ở dưới mục có tiêu đề là ``Changes to be committed''.
Nếu bây giờ bạn commit thì nội dung của file tại thời điểm chạy `git add` sẽ ở trong snapshot.
Lệnh `git add` sử dụng pathname của file hoặc thư mục; nếu nó là một thư muc, lệnh sẽ add toàn bộ các file trong thư mục đó.

==== Staging Modified Files

Bây giờ thay đổi một file đã được track (tracked file).
Nếu bạn thay đổi một tracked file tên là `CONTRIBUTING.md` và sau đó chạy lệnh `git status`, bạn sẽ thấy kết quả như sau:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

`CONTRIBUTING.md` xuất hiện trong phần có tên là ``Changes not staged for commit'' -- nó có nghĩa rằng một file đã được track và nội dung của nó đã thay đổi so với snapshot mới nhất, nhưng nó vẫn chưa được stage.
Để stage nó, chạy lệnh `git add`.
`git add` là lệnh có nhiều mục đích -- nó có thể sử dụng để bắt đầu track một file mới, để stage file, và làm những việc khác như đánh dấu các merge-conflicted file ở trạng thái resolved.
Sau khi đã stage nó, chạy lại lệnh `git status`, ta được như sau:

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

----

Cả hai file bây giờ đã được stage và sẵn sàng cho commit.
Ở thời điểm bây giờ, giả sử bạn nhớ rằng bạn muốn sửa nội dung của `CONTRIBUTING.md` trước khi bạn commit nó.
Bạn mở nó lại và sửa nó như ý muốn, và sửa xong giờ bạn đã sẵn sàng để commit nó.
Bây giờ, ta chạy lại lệnh `git status` sẽ thấy như sau:

[source,console]
----
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

----

Chuyện gì xảy ra vậy?
`CONTRIBUTING.md` có cả ở cả 2 trạng thái là unstaged và staged.
Nếu bây giờ bạn commit thì nội dung file tại thời điểm chạy lệnh `git add` sẽ ở trong snapshot chứ không phải phiên bản bạn sửa cuối cùng.
Nếu bạn sửa một file sau khi bạn chạy lệnh `git add` thì bạn phải chạy lại lệnh `git add` để stage phiên bản cuối cùng của file.

[source,console]
----
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
----

==== Short Status

Kết quả của chạy lệnh `git status` chi tiết, nhưng nó cũng quá dài dòng.
Git cho phép hiển thị status ngắn gọn hơn bằng lệnh `git status -s` hoặc `git status --short` như sau:

[source,console]
----
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
----

Các file không được track có dấu `??` ở trước, các file mới mà đã được stage thì phía trước có dấu `A`, các file đã sửa có dấu `M` và vân vân.
Có hai cột được sử dụng: cột bên trái cùng là trạng thái của vùng staging và cột bên phải là trạng thái của working directory.
Ví dụ, trong short status ở trên, `README` được sửa trong working directory nhưng vẫn chưa được stage, trong khi `lib/simplegit.rb` đã được sửa và được stage. `Rakefile` đã được sửa, được stage và sửa lại.

[[_ignoring]]
==== Ignoring Files

Thông thường, bạn sẽ có một lớp các file bạn không muốn git tự động add hoặc thậm chí là hiển thị trạng thái untracked.
Thường thì đây là các file tự động được tạo ra như log gile hoặc các file được tạo ra trong quá trình build.
Trong các trường hợp như thế, bạn có thể tạo một file chứa pattern có tên là `.gitignore`.(((ignoring files)))
Đây là một ví dụ về `.gitignore`:

[source,console]
----
$ cat .gitignore
*.[oa]
*~
----

Dòng đầu tiên nói với Git bỏ qua bất kì file nào kết thúc với ``.o'' hoặc ``.a'' -- đây là các object file và archive file được tạo ra trong quá trình build.
Dòng thứ hai nói với git bỏ qua tất cả các file mà tên của nó kết thúc với dấu `~`, đây là kí tự được sử dụng bởi nhừ text editor như Emacs để chỉ thị đó là tệp tạm thời.
Việc sử dụng `.gitignore` cho repository mới trước khi bạn bắt đầu làm việc là một ý tưởng hay để bạn không commit những file bạn không muốn nó có trong Git repository.

Luật cho pattern của `.gitignore` như sau:

*  Các dòng trống hoặc các dòng bắt đầu bằng kí tự `#` sẽ bị bỏ qua.
*  Các pattern theo chuẩn glob được sử dụng
*  
*  You can start patterns with a forward slash (`/`) to avoid recursivity.
*  You can end patterns with a forward slash (`/`) to specify a directory.
*  You can negate a pattern by starting it with an exclamation point (`!`).

Glob patterns are like simplified regular expressions that shells use.
An asterisk (`*`) matches zero or more characters; `[abc]` matches any character inside the brackets (in this case a, b, or c); a question mark (`?`) matches a single character; and brackets enclosing characters separated by a hyphen (`[0-9]`) matches any character between them (in this case 0 through 9).
You can also use two asterisks to match nested directories; `a/**/z` would match `a/z`, `a/b/z`, `a/b/c/z`, and so on.

Here is another example `.gitignore` file:

[source]
----
# ignore all .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in any directory named build
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory and any of its subdirectories
doc/**/*.pdf
----

[TIP]
====
GitHub maintains a fairly comprehensive list of good `.gitignore` file examples for dozens of projects and languages at https://github.com/github/gitignore[] if you want a starting point for your project.
====

[NOTE]
====
In the simple case, a repository might have a single `.gitignore` file in its root directory, which applies recursively to the entire repository.
However, it is also possible to have additional `.gitignore` files in subdirectories.
The rules in these nested `.gitignore` files apply only to the files under the directory where they are located.
(The Linux kernel source repository has 206 `.gitignore` files.)

It is beyond the scope of this book to get into the details of multiple `.gitignore` files; see `man gitignore` for the details.
====

[[_git_diff_staged]]
==== Viewing Your Staged and Unstaged Changes

If the `git status` command is too vague for you -- you want to know exactly what you changed, not just which files were changed -- you can use the `git diff` command.(((git commands, diff)))
We'll cover `git diff` in more detail later, but you'll probably use it most often to answer these two questions: What have you changed but not yet staged?
And what have you staged that you are about to commit?
Although `git status` answers those questions very generally by listing the file names, `git diff` shows you the exact lines added and removed -- the patch, as it were.

Let's say you edit and stage the `README` file again and then edit the `CONTRIBUTING.md` file without staging it.
If you run your `git status` command, you once again see something like this:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

To see what you've changed but not yet staged, type `git diff` with no other arguments:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

That command compares what is in your working directory with what is in your staging area.
The result tells you the changes you've made that you haven't yet staged.

If you want to see what you've staged that will go into your next commit, you can use `git diff --staged`.
This command compares your staged changes to your last commit:

[source,console]
----
$ git diff --staged
diff --git a/README b/README
new file mode 100644
index 0000000..03902a1
--- /dev/null
+++ b/README
@@ -0,0 +1 @@
+My Project
----

It's important to note that `git diff` by itself doesn't show all changes made since your last commit -- only changes that are still unstaged.
If you've staged all of your changes, `git diff` will give you no output.

For another example, if you stage the `CONTRIBUTING.md` file and then edit it, you can use `git diff` to see the changes in the file that are staged and the changes that are unstaged.
If our environment looks like this:

[source,console]
----
$ git add CONTRIBUTING.md
$ echo '# test line' >> CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
----

Now you can use `git diff` to see what is still unstaged:

[source,console]
----
$ git diff
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 643e24f..87f08c8 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -119,3 +119,4 @@ at the
 ## Starter Projects

 See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).
+# test line
----

and `git diff --cached` to see what you've staged so far (`--staged` and `--cached` are synonyms):

[source,console]
----
$ git diff --cached
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index 8ebb991..643e24f 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -65,7 +65,8 @@ branch directly, things can get messy.
 Please include a nice description of your changes when you submit your PR;
 if we have to read the whole diff to figure out why you're contributing
 in the first place, you're less likely to get feedback and have your change
-merged in.
+merged in. Also, split your changes into comprehensive chunks if your patch is
+longer than a dozen lines.

 If you are starting to work on a particular area, feel free to submit a PR
 that highlights your work in progress (and note in the PR title that it's
----

[NOTE]
.Git Diff in an External Tool
====
We will continue to use the `git diff` command in various ways throughout the rest of the book.
There is another way to look at these diffs if you prefer a graphical or external diff viewing program instead.
If you run `git difftool` instead of `git diff`, you can view any of these diffs in software like emerge, vimdiff and many more (including commercial products).
Run `git difftool --tool-help` to see what is available on your system.
====

[[_committing_changes]]
==== Committing Your Changes

Now that your staging area is set up the way you want it, you can commit your changes.
Remember that anything that is still unstaged -- any files you have created or modified that you haven't run `git add` on since you edited them -- won't go into this commit.
They will stay as modified files on your disk.
In this case, let's say that the last time you ran `git status`, you saw that everything was staged, so you're ready to commit your changes.(((git commands, status)))
The simplest way to commit is to type `git commit`:(((git commands, commit)))

[source,console]
----
$ git commit
----

Doing so launches your editor of choice.
(This is set by your shell's `EDITOR` environment variable -- usually vim or emacs, although you can configure it with whatever you want using the `git config --global core.editor` command as you saw in <<ch01-getting-started#ch01-getting-started>>).(((editor, changing default)))(((git commands, config)))

The editor displays the following text (this example is a Vim screen):

[source]
----

# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Your branch is up-to-date with 'origin/master'.
#
# Changes to be committed:
#	new file:   README
#	modified:   CONTRIBUTING.md
#
~
~
~
".git/COMMIT_EDITMSG" 9L, 283C
----

You can see that the default commit message contains the latest output of the `git status` command commented out and one empty line on top.
You can remove these comments and type your commit message, or you can leave them there to help you remember what you're committing.
(For an even more explicit reminder of what you've modified, you can pass the `-v` option to `git commit`.
Doing so also puts the diff of your change in the editor so you can see exactly what changes you're committing.)
When you exit the editor, Git creates your commit with that commit message (with the comments and diff stripped out).

Alternatively, you can type your commit message inline with the `commit` command by specifying it after a `-m` flag, like this:

[source,console]
----
$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README
----

Now you've created your first commit!
You can see that the commit has given you some output about itself: which branch you committed to (`master`), what SHA-1 checksum the commit has (`463dc4f`), how many files were changed, and statistics about lines added and removed in the commit.

Remember that the commit records the snapshot you set up in your staging area.
Anything you didn't stage is still sitting there modified; you can do another commit to add it to your history.
Every time you perform a commit, you're recording a snapshot of your project that you can revert to or compare to later.

==== Skipping the Staging Area

(((staging area, skipping)))
Although it can be amazingly useful for crafting commits exactly how you want them, the staging area is sometimes a bit more complex than you need in your workflow.
If you want to skip the staging area, Git provides a simple shortcut.
Adding the `-a` option to the `git commit` command makes Git automatically stage every file that is already tracked before doing the commit, letting you skip the `git add` part:

[source,console]
----
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

no changes added to commit (use "git add" and/or "git commit -a")
$ git commit -a -m 'added new benchmarks'
[master 83e38c7] added new benchmarks
 1 file changed, 5 insertions(+), 0 deletions(-)
----

Notice how you don't have to run `git add` on the `CONTRIBUTING.md` file in this case before you commit.
That's because the `-a` flag includes all changed files.
This is convenient, but be careful; sometimes this flag will cause you to include unwanted changes.

[[_removing_files]]
==== Removing Files

(((files, removing)))
To remove a file from Git, you have to remove it from your tracked files (more accurately, remove it from your staging area) and then commit.
The `git rm` command does that, and also removes the file from your working directory so you don't see it as an untracked file the next time around.

If you simply remove the file from your working directory, it shows up under the ``Changes not staged for commit'' (that is, _unstaged_) area of your `git status` output:

[source,console]
----
$ rm PROJECTS.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    PROJECTS.md

no changes added to commit (use "git add" and/or "git commit -a")
----

Then, if you run `git rm`, it stages the file's removal:

[source,console]
----
$ git rm PROJECTS.md
rm 'PROJECTS.md'
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    deleted:    PROJECTS.md
----

The next time you commit, the file will be gone and no longer tracked.
If you modified the file and added it to the staging area already, you must force the removal with the `-f` option.
This is a safety feature to prevent accidental removal of data that hasn't yet been recorded in a snapshot and that can't be recovered from Git.

Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area.
In other words, you may want to keep the file on your hard drive but not have Git track it anymore.
This is particularly useful if you forgot to add something to your `.gitignore` file and accidentally staged it, like a large log file or a bunch of `.a` compiled files.
To do this, use the `--cached` option:

[source,console]
----
$ git rm --cached README
----

You can pass files, directories, and file-glob patterns to the `git rm` command.
That means you can do things such as:

[source,console]
----
$ git rm log/\*.log
----

Note the backslash (`\`) in front of the `*`.
This is necessary because Git does its own filename expansion in addition to your shell's filename expansion.
This command removes all files that have the `.log` extension in the `log/` directory.
Or, you can do something like this:

[source,console]
----
$ git rm \*~
----

This command removes all files whose names end with a `~`.

[[_git_mv]]
==== Moving Files

(((files, moving)))
Unlike many other VCS systems, Git doesn't explicitly track file movement.
If you rename a file in Git, no metadata is stored in Git that tells it you renamed the file.
However, Git is pretty smart about figuring that out after the fact -- we'll deal with detecting file movement a bit later.

Thus it's a bit confusing that Git has a `mv` command.
If you want to rename a file in Git, you can run something like:

[source,console]
----
$ git mv file_from file_to
----

and it works fine.
In fact, if you run something like this and look at the status, you'll see that Git considers it a renamed file:

[source,console]
----
$ git mv README.md README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    renamed:    README.md -> README
----

However, this is equivalent to running something like this:

[source,console]
----
$ mv README.md README
$ git rm README.md
$ git add README
----

Git figures out that it's a rename implicitly, so it doesn't matter if you rename a file that way or with the `mv` command.
The only real difference is that `git mv` is one command instead of three -- it's a convenience function.
More importantly, you can use any tool you like to rename a file, and address the add/rm later, before you commit.
